# coding: utf-8

"""
ExpertApi.py
Copyright 2015 SmartBear Software

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
"""

from __future__ import absolute_import

import sys
import os

# python 2 and python 3 compatibility library
from six import iteritems

from ..configuration import Configuration
from ..api_client import ApiClient


class ExpertApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        config = Configuration()
        if api_client:
            self.api_client = api_client
        else:
            if not config.api_client:
                config.api_client = ApiClient()
            self.api_client = config.api_client

    def create_global_tag(self, **kwargs):
        """
        Create a GlobalTag.
        Input data are in json, and should match all needed fields for a new global tag.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_global_tag(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param GlobalTag body: 
        :return: GlobalTag
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_global_tag" % key
                )
            params[key] = val
        del params['kwargs']


        resource_path = '/expert/globaltags'.replace('{format}', 'json')
        method = 'POST'

        path_params = {}

        query_params = {}

        header_params = {}

        form_params = {}
        files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        response = self.api_client.call_api(resource_path, method,
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=files,
                                            response_type='GlobalTag',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def map_tags_to_global_tag(self, id, **kwargs):
        """
        Map a tag to a globaltag.
        Can be used for one or many tags.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.map_tags_to_global_tag(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: id: id of the globaltag to be updated (required)
        :param str action: action: {addtags(default)|merge}. If merge is used, the input map should contain a global tag name. All associated tag will then be also associated to the global tag identified by {id}.
        :param Body body: 
        :return: GlobalTag
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'action', 'body']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method map_tags_to_global_tag" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `map_tags_to_global_tag`")

        resource_path = '/expert/globaltags/maps/{id}'.replace('{format}', 'json')
        method = 'POST'

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'action' in params:
            query_params['action'] = params['action']

        header_params = {}

        form_params = {}
        files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        response = self.api_client.call_api(resource_path, method,
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=files,
                                            response_type='GlobalTag',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def update_global_tag(self, id, **kwargs):
        """
        Update a GlobalTag.
        Input data are in json, and should match all  fields to be updated.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_global_tag(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: id: id of the globaltag to be updated (required)
        :param Body1 body: 
        :return: GlobalTag
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_global_tag" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_global_tag`")

        resource_path = '/expert/globaltags/{id}'.replace('{format}', 'json')
        method = 'POST'

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}

        header_params = {}

        form_params = {}
        files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        response = self.api_client.call_api(resource_path, method,
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=files,
                                            response_type='GlobalTag',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def delete_global_tag(self, id, **kwargs):
        """
        Delete a globaltag.
        It should be used one global tag at the time. This method is meant for administration purposes.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_global_tag(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: id: id of the globaltag to be deleted (required)
        :return: GlobalTag
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_global_tag" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_global_tag`")

        resource_path = '/expert/globaltags/{id}'.replace('{format}', 'json')
        method = 'DELETE'

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}

        header_params = {}

        form_params = {}
        files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/xml'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        response = self.api_client.call_api(resource_path, method,
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=files,
                                            response_type='GlobalTag',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def create_iov(self, **kwargs):
        """
        Create an IOV entry.
        Input data are in json, and should match all needed fields for a new Iov. Here the problem is to know the hash of the payload.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_iov(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param Iov body: 
        :return: Iov
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_iov" % key
                )
            params[key] = val
        del params['kwargs']


        resource_path = '/expert/iovs'.replace('{format}', 'json')
        method = 'POST'

        path_params = {}

        query_params = {}

        header_params = {}

        form_params = {}
        files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json', 'application/xml'])

        # Authentication setting
        auth_settings = []

        response = self.api_client.call_api(resource_path, method,
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=files,
                                            response_type='Iov',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def async_create_iov_with_payload(self, file, streamer_info, object_type, backend_info, version, since, since_string, tag, **kwargs):
        """
        Create an IOV entry with its own payload.
        Input data are inside a FORM. It should contain: file, streamerInfo, objectType, backendInfo, version, since, sinceString, tag.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.async_create_iov_with_payload(file, streamer_info, object_type, backend_info, version, since, since_string, tag, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param file file: file: the filename of the input payload (required)
        :param str streamer_info: streamerInfo: the streamer information of the input payload (required)
        :param str object_type: objectType: the object type of the input payload (required)
        :param str backend_info: backendInfo: the backend system of the input payload (required)
        :param str version: version: the version of the input payload (required)
        :param float since: since: the since time of the IOV. (required)
        :param str since_string: sinceString: the since time string representation of the IOV. (required)
        :param str tag: tag: the tag name where to store the IOV. (required)
        :return: Iov
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file', 'streamer_info', 'object_type', 'backend_info', 'version', 'since', 'since_string', 'tag']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method async_create_iov_with_payload" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'file' is set
        if ('file' not in params) or (params['file'] is None):
            raise ValueError("Missing the required parameter `file` when calling `async_create_iov_with_payload`")
        # verify the required parameter 'streamer_info' is set
        if ('streamer_info' not in params) or (params['streamer_info'] is None):
            raise ValueError("Missing the required parameter `streamer_info` when calling `async_create_iov_with_payload`")
        # verify the required parameter 'object_type' is set
        if ('object_type' not in params) or (params['object_type'] is None):
            raise ValueError("Missing the required parameter `object_type` when calling `async_create_iov_with_payload`")
        # verify the required parameter 'backend_info' is set
        if ('backend_info' not in params) or (params['backend_info'] is None):
            raise ValueError("Missing the required parameter `backend_info` when calling `async_create_iov_with_payload`")
        # verify the required parameter 'version' is set
        if ('version' not in params) or (params['version'] is None):
            raise ValueError("Missing the required parameter `version` when calling `async_create_iov_with_payload`")
        # verify the required parameter 'since' is set
        if ('since' not in params) or (params['since'] is None):
            raise ValueError("Missing the required parameter `since` when calling `async_create_iov_with_payload`")
        # verify the required parameter 'since_string' is set
        if ('since_string' not in params) or (params['since_string'] is None):
            raise ValueError("Missing the required parameter `since_string` when calling `async_create_iov_with_payload`")
        # verify the required parameter 'tag' is set
        if ('tag' not in params) or (params['tag'] is None):
            raise ValueError("Missing the required parameter `tag` when calling `async_create_iov_with_payload`")

        resource_path = '/expert/iovs/async/payload'.replace('{format}', 'json')
        method = 'POST'

        path_params = {}

        query_params = {}

        header_params = {}

        form_params = {}
        files = {}
        if 'file' in params:
            files['file'] = params['file']
        if 'streamer_info' in params:
            form_params['streamerInfo'] = params['streamer_info']
        if 'object_type' in params:
            form_params['objectType'] = params['object_type']
        if 'backend_info' in params:
            form_params['backendInfo'] = params['backend_info']
        if 'version' in params:
            form_params['version'] = params['version']
        if 'since' in params:
            form_params['since'] = params['since']
        if 'since_string' in params:
            form_params['sinceString'] = params['since_string']
        if 'tag' in params:
            form_params['tag'] = params['tag']

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/xml'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = []

        response = self.api_client.call_api(resource_path, method,
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=files,
                                            response_type='Iov',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def create_iov_with_payload(self, file, streamer_info, object_type, backend_info, version, since, since_string, tag, **kwargs):
        """
        Create an IOV entry with its own payload.
        Input data are inside a FORM. It should contain: file, streamerInfo, objectType, backendInfo, version, since, sinceString, tag.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_iov_with_payload(file, streamer_info, object_type, backend_info, version, since, since_string, tag, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param file file: file: the filename of the input payload (required)
        :param str streamer_info: streamerInfo: the streamer information of the input payload (required)
        :param str object_type: objectType: the object type of the input payload (required)
        :param str backend_info: backendInfo: the backend system of the input payload (required)
        :param str version: version: the version of the input payload (required)
        :param float since: since: the since time of the IOV. (required)
        :param str since_string: sinceString: the since time string representation of the IOV. (required)
        :param str tag: tag: the tag name where to store the IOV. (required)
        :return: Iov
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file', 'streamer_info', 'object_type', 'backend_info', 'version', 'since', 'since_string', 'tag']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_iov_with_payload" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'file' is set
        if ('file' not in params) or (params['file'] is None):
            raise ValueError("Missing the required parameter `file` when calling `create_iov_with_payload`")
        # verify the required parameter 'streamer_info' is set
        if ('streamer_info' not in params) or (params['streamer_info'] is None):
            raise ValueError("Missing the required parameter `streamer_info` when calling `create_iov_with_payload`")
        # verify the required parameter 'object_type' is set
        if ('object_type' not in params) or (params['object_type'] is None):
            raise ValueError("Missing the required parameter `object_type` when calling `create_iov_with_payload`")
        # verify the required parameter 'backend_info' is set
        if ('backend_info' not in params) or (params['backend_info'] is None):
            raise ValueError("Missing the required parameter `backend_info` when calling `create_iov_with_payload`")
        # verify the required parameter 'version' is set
        if ('version' not in params) or (params['version'] is None):
            raise ValueError("Missing the required parameter `version` when calling `create_iov_with_payload`")
        # verify the required parameter 'since' is set
        if ('since' not in params) or (params['since'] is None):
            raise ValueError("Missing the required parameter `since` when calling `create_iov_with_payload`")
        # verify the required parameter 'since_string' is set
        if ('since_string' not in params) or (params['since_string'] is None):
            raise ValueError("Missing the required parameter `since_string` when calling `create_iov_with_payload`")
        # verify the required parameter 'tag' is set
        if ('tag' not in params) or (params['tag'] is None):
            raise ValueError("Missing the required parameter `tag` when calling `create_iov_with_payload`")

        resource_path = '/expert/iovs/payload'.replace('{format}', 'json')
        method = 'POST'

        path_params = {}

        query_params = {}

        header_params = {}

        form_params = {}
        files = {}
        if 'file' in params:
            files['file'] = params['file']
        if 'streamer_info' in params:
            form_params['streamerInfo'] = params['streamer_info']
        if 'object_type' in params:
            form_params['objectType'] = params['object_type']
        if 'backend_info' in params:
            form_params['backendInfo'] = params['backend_info']
        if 'version' in params:
            form_params['version'] = params['version']
        if 'since' in params:
            form_params['since'] = params['since']
        if 'since_string' in params:
            form_params['sinceString'] = params['since_string']
        if 'tag' in params:
            form_params['tag'] = params['tag']

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/xml'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = []

        response = self.api_client.call_api(resource_path, method,
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=files,
                                            response_type='Iov',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def delete_iov(self, id, **kwargs):
        """
        Delete an IOV.
        It should be used one IOV at the time. This method is meant for administration purposes. The payload associated is not removed.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_iov(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int id: id: id of the IOV to be deleted (required)
        :return: Iov
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_iov" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_iov`")

        resource_path = '/expert/iovs/{id}'.replace('{format}', 'json')
        method = 'DELETE'

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}

        header_params = {}

        form_params = {}
        files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/xml'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        response = self.api_client.call_api(resource_path, method,
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=files,
                                            response_type='Iov',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def create_global_tag_map(self, body, **kwargs):
        """
        Create a GlobalTagMap.
        Input data are in json, and should match all needed fields for a new global tag to tag association.\nThese key fields are: globaltagname, tagname, record and label.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_global_tag_map(body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param Body2 body: a json entry corresponding to mapping parameters. (required)
        :return: GlobalTagMap
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_global_tag_map" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_global_tag_map`")

        resource_path = '/expert/maps'.replace('{format}', 'json')
        method = 'POST'

        path_params = {}

        query_params = {}

        header_params = {}

        form_params = {}
        files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/xml'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json', 'application/xml'])

        # Authentication setting
        auth_settings = []

        response = self.api_client.call_api(resource_path, method,
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=files,
                                            response_type='GlobalTagMap',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def update_global_tag_map(self, id, **kwargs):
        """
        Update a GlobalTagMap association.
        Input data are in json, and should match the fields that can be updated: record and label.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_global_tag_map(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int id: id: id of the globaltagmap to be updated (required)
        :param Body3 body: 
        :return: GlobalTagMap
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_global_tag_map" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_global_tag_map`")

        resource_path = '/expert/maps/{id}'.replace('{format}', 'json')
        method = 'POST'

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}

        header_params = {}

        form_params = {}
        files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/xml'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        response = self.api_client.call_api(resource_path, method,
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=files,
                                            response_type='GlobalTagMap',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def delete_global_tag_map(self, id, **kwargs):
        """
        Delete a globaltag mapping.
        It should be used one global tag at the time. This method is meant for administration purposes.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_global_tag_map(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int id: id: id of the association to be deleted (required)
        :return: GlobalTagMap
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_global_tag_map" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_global_tag_map`")

        resource_path = '/expert/maps/{id}'.replace('{format}', 'json')
        method = 'DELETE'

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}

        header_params = {}

        form_params = {}
        files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/xml'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        response = self.api_client.call_api(resource_path, method,
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=files,
                                            response_type='GlobalTagMap',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def create_payload(self, file, type, streamer, version, **kwargs):
        """
        Insert a Payload.
        Input data are in a FORM, containing file, type, streamer and version information.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_payload(file, type, streamer, version, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param file file: file: the input file (required)
        :param str type: type: the object type (required)
        :param str streamer: streamer: streamer information (required)
        :param str version: version: the version string (required)
        :return: Payload
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file', 'type', 'streamer', 'version']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_payload" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'file' is set
        if ('file' not in params) or (params['file'] is None):
            raise ValueError("Missing the required parameter `file` when calling `create_payload`")
        # verify the required parameter 'type' is set
        if ('type' not in params) or (params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `create_payload`")
        # verify the required parameter 'streamer' is set
        if ('streamer' not in params) or (params['streamer'] is None):
            raise ValueError("Missing the required parameter `streamer` when calling `create_payload`")
        # verify the required parameter 'version' is set
        if ('version' not in params) or (params['version'] is None):
            raise ValueError("Missing the required parameter `version` when calling `create_payload`")

        resource_path = '/expert/payload'.replace('{format}', 'json')
        method = 'POST'

        path_params = {}

        query_params = {}

        header_params = {}

        form_params = {}
        files = {}
        if 'file' in params:
            files['file'] = params['file']
        if 'type' in params:
            form_params['type'] = params['type']
        if 'streamer' in params:
            form_params['streamer'] = params['streamer']
        if 'version' in params:
            form_params['version'] = params['version']

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/xml'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = []

        response = self.api_client.call_api(resource_path, method,
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=files,
                                            response_type='Payload',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def create_system_description(self, body, **kwargs):
        """
        Create a System Description entity.
        Input data are in json, and should match all needed fields for a new System Description.\nSystem Description has to be unique for the node fullpath name. The tagNameRoot is unique as well.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_system_description(body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param SystemDescription body: A json entry corresponding to SystemDescription (required)
        :return: SystemDescription
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_system_description" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_system_description`")

        resource_path = '/expert/systems'.replace('{format}', 'json')
        method = 'POST'

        path_params = {}

        query_params = {}

        header_params = {}

        form_params = {}
        files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/xml'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json', 'application/xml'])

        # Authentication setting
        auth_settings = []

        response = self.api_client.call_api(resource_path, method,
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=files,
                                            response_type='SystemDescription',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def update_system_description(self, id, **kwargs):
        """
        Update a System Description.
        Input data are in json, and should match the fields that can be updated: nodeDescription and groupSize (used in pagination queries).

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_system_description(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: system: id of the system description to be updated (required)
        :param Body4 body: 
        :return: SystemDescription
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_system_description" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_system_description`")

        resource_path = '/expert/systems/{id}'.replace('{format}', 'json')
        method = 'POST'

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}

        header_params = {}

        form_params = {}
        files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/xml'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        response = self.api_client.call_api(resource_path, method,
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=files,
                                            response_type='SystemDescription',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def delete_system_description(self, id, **kwargs):
        """
        Delete a system description.
        It should be used one system at the time. This method is meant for administration purposes.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_system_description(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int id: id: id of the system description to be deleted (required)
        :return: SystemDescription
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_system_description" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_system_description`")

        resource_path = '/expert/systems/{id}'.replace('{format}', 'json')
        method = 'DELETE'

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}

        header_params = {}

        form_params = {}
        files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        response = self.api_client.call_api(resource_path, method,
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=files,
                                            response_type='SystemDescription',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def create_tag(self, **kwargs):
        """
        Create a new Tag.
        Creation requires the full needed information in json.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_tag(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param Tag body: 
        :return: Tag
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_tag" % key
                )
            params[key] = val
        del params['kwargs']


        resource_path = '/expert/tags'.replace('{format}', 'json')
        method = 'POST'

        path_params = {}

        query_params = {}

        header_params = {}

        form_params = {}
        files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/xml'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json', 'application/xml'])

        # Authentication setting
        auth_settings = []

        response = self.api_client.call_api(resource_path, method,
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=files,
                                            response_type='Tag',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def update_tag(self, id, **kwargs):
        """
        Update an existing Tag.
        Requires in the input json the needed fields to be updated. Cannot update a locked tag.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_tag(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: id: the name of the tag to be updated (required)
        :param Body5 body: 
        :return: Tag
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_tag" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_tag`")

        resource_path = '/expert/tags/{id}'.replace('{format}', 'json')
        method = 'POST'

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}

        header_params = {}

        form_params = {}
        files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/xml'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        response = self.api_client.call_api(resource_path, method,
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=files,
                                            response_type='Tag',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def delete_tag(self, id, **kwargs):
        """
        Delete a tag.
        It should be used on one tag at the time. This method is meant for administration purposes.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_tag(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: id: the name of the tag to be updated (required)
        :return: Tag
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_tag" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_tag`")

        resource_path = '/expert/tags/{id}'.replace('{format}', 'json')
        method = 'DELETE'

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}

        header_params = {}

        form_params = {}
        files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/xml'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = []

        response = self.api_client.call_api(resource_path, method,
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=files,
                                            response_type='Tag',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response
